from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, BotCommand
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, MessageHandler, ContextTypes, filters
from database import init_db, add_user, get_all_user_ids
import json
import os
import re
from datetime import datetime

TOKEN = "7827624867:AAHMzn2bI4kwjTGUmWp621I95HkeNFByDeU"
ADMIN_IDS = [829510841]
channel_id = -1002894773514
DATA_FILE = "series_data.json"
USAGE_LOG_FILE = "usage_log.json"
PENDING_ADDS = {}
EPISODES_PER_PAGE = 20

# ========== ÿ•ÿπÿØÿßÿØÿßÿ™ ==========
SERIES_PER_ROW = 3  # ÿπÿØÿØ ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑÿßÿ™ ŸÅŸä ŸÉŸÑ ÿµŸÅ

# ========== ÿ£ÿØŸàÿßÿ™ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ ŸàÿßŸÑÿ≠ŸÅÿ∏ ==========
def load_series_data():
    if not os.path.exists(DATA_FILE):
        return {}
    with open(DATA_FILE, "r", encoding="utf-8") as f:
        return json.load(f)

def save_series_data(data):
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def log_usage(user, action, extra=""):
    entry = {
        "user_id": user.id,
        "username": user.username or "",
        "name": f"{user.first_name} {user.last_name or ''}".strip(),
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "action": action,
        "extra": extra
    }
    print("‚úÖ log_usage entry:", entry)
    logs = []
    if os.path.exists(USAGE_LOG_FILE):
        with open(USAGE_LOG_FILE, "r", encoding="utf-8") as f:
            try:
                logs = json.load(f)
            except json.JSONDecodeError:
                logs = []
    logs.append(entry)
    with open(USAGE_LOG_FILE, "w", encoding="utf-8") as f:
        json.dump(logs, f, ensure_ascii=False, indent=2)

def is_admin(user_id):
    return user_id in ADMIN_IDS

async def is_user_subscribed(user_id: int, context: ContextTypes.DEFAULT_TYPE) -> bool:
    try:
        member = await context.bot.get_chat_member(chat_id=channel_id, user_id=user_id)
        return member.status in ["member", "administrator", "creator"]
    except:
        return False

def sanitize_callback(text):
    return re.sub(r"[^\w\d]", "", text).strip()[:20]


# ========== ÿ™ŸàŸÑŸäÿØ ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑŸÖŸàÿßÿ≥ŸÖ ŸàÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ==========
# ‚úÖ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿµ ŸÖŸÜ ÿßŸÑÿ±ŸÖŸàÿ≤ ŸÑÿ™ŸÅÿßÿØŸä ÿ£ÿÆÿ∑ÿßÿ° callback_data

def sanitize_callback(text):
    return re.sub(r"[^\w\d]", "", text).strip()[:20]  # ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ±ŸÖŸàÿ≤ ŸàŸÇÿµÿ± ÿßŸÑŸÜÿµ

# ========== ÿ™ŸàŸÑŸäÿØ ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑŸÖŸàÿßÿ≥ŸÖ ŸàÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ==========
def generate_season_buttons(series_data, series_name):
    return [[InlineKeyboardButton(season_name, callback_data=f"season|{sanitize_callback(series_name)}|{sanitize_callback(season_name)}")]
            for season_name in series_data[series_name].keys()] + [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data="back_to_series")]]

def generate_episode_buttons(episodes: dict, series_name: str, season_name: str, page: int = 0, per_row: int = 4):
    keys_sorted = sorted([k.strip() for k in episodes.keys() if k.strip().isdigit()], key=lambda x: int(x))
    total = len(keys_sorted)
    start = page * EPISODES_PER_PAGE
    end = start + EPISODES_PER_PAGE
    paginated = keys_sorted[start:end]
    buttons = []
    for i in range(0, len(paginated), per_row):
        row = [
            InlineKeyboardButton(
                f"ÿ≠ŸÑŸÇÿ© {int(ep)}",
                callback_data=f"episode|{sanitize_callback(series_name)}|{sanitize_callback(season_name)}|{ep}"
            )
            for ep in paginated[i:i + per_row]
        ]
        buttons.append(row)
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton(
            "‚¨ÖÔ∏è ÿßŸÑÿ≥ÿßÿ®ŸÇ",
            callback_data=f"season|{sanitize_callback(series_name)}|{sanitize_callback(season_name)}|{page-1}"
        ))
    if end < total:
        nav_buttons.append(InlineKeyboardButton(
            "ÿßŸÑÿ™ÿßŸÑŸä ‚û°Ô∏è",
            callback_data=f"season|{sanitize_callback(series_name)}|{sanitize_callback(season_name)}|{page+1}"
        ))
    if nav_buttons:
        buttons.append(nav_buttons)
    buttons.append([InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data=f"back_to_seasons|{sanitize_callback(series_name)}")])
    return buttons

# ========== ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ==========

def log_usage(user, action, extra="-"):
    log_entry = {
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "name": user.first_name,
        "username": user.username or "-",
        "action": action,
        "extra": extra
    }

    try:
        with open("usage_log.json", "r", encoding="utf-8") as f:
            logs = json.load(f)
    except FileNotFoundError:
        logs = []

    logs.append(log_entry)

    with open("usage_log.json", "w", encoding="utf-8") as f:
        json.dump(logs, f, ensure_ascii=False, indent=2)

# ========== broadcast ==========
BATCH_SIZE = 30
DELAY_BETWEEN_BATCHES = 1  # ÿ´ŸàÿßŸÜŸä

async def try_send(bot, user_id, message):
    try:
        await bot.send_message(chat_id=user_id, text=message)
        return "success"
    except Exception as e:
        print(f"‚ùå ŸÅÿ¥ŸÑ ŸÖÿπ {user_id}: {e}")
        return "fail"

async def broadcast_message(context: ContextTypes.DEFAULT_TYPE, message: str):
    users = get_all_user_ids()
    success, failed = 0, 0

    for i in range(0, len(users), BATCH_SIZE):
        batch = users[i:i+BATCH_SIZE]

        # ‚úÖ ŸáŸÜÿß ŸÖŸÉÿßŸÜ ÿ∑ÿ®ÿßÿπÿ© ÿ±ŸÇŸÖ ÿßŸÑÿØŸÅÿπÿ©
        print(f"üì¶ Batch {(i // BATCH_SIZE) + 1} - ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ ŸÑŸÄ {len(batch)} ŸÖÿ≥ÿ™ÿÆÿØŸÖ")

        results = await asyncio.gather(*[
            try_send(context.bot, user_id, message)
            for user_id in batch
        ])
        success += results.count("success")
        failed += results.count("fail")
        await asyncio.sleep(DELAY_BETWEEN_BATCHES)

    # ‚úÖ ÿ™ÿ±ÿ¨ÿπ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ŸÑÿØÿßŸÑÿ© broadcast_command
    return success, failed

# ========== /ÿßÿ±ÿ≥ÿßŸÑ ÿßÿπŸÑÿßŸÜ ==========
async def handle_broadcast_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user

    if not is_admin(user.id):
        return

    if context.user_data.get("awaiting_broadcast"):
        context.user_data["awaiting_broadcast"] = False
        context.user_data["pending_broadcast_message"] = update.message.text

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚úÖ ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ", callback_data="confirm_broadcast")],
            [InlineKeyboardButton("‚ùå ÿ•ŸÑÿ∫ÿßÿ°", callback_data="admin")]
        ])

        await update.message.reply_text(
            f"üì¢ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ±ÿßÿØ ÿ•ÿ±ÿ≥ÿßŸÑŸáÿß:\n\n{update.message.text}",
            reply_markup=keyboard
        )

# ========== /ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑÿßÿ™ ==========
async def handle_series_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user

    if not context.user_data.get("awaiting_series_search"):
        return

    context.user_data["awaiting_series_search"] = False
    query = update.message.text.lower()
    series_data = load_series_data()

    results = []

    for series_name, series_info in series_data.items():
        # ÿ®ÿ≠ÿ´ ŸÅŸä ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑ ŸÜŸÅÿ≥Ÿá
        if query in series_name.lower():
            results.append(("series", series_name))

        # ÿ®ÿ≠ÿ´ ÿØÿßÿÆŸÑ ÿßŸÑŸÖŸàÿßÿ≥ŸÖ
        for season_name, episodes in series_info.items():
            if not isinstance(episodes, dict):
                continue

            if query in season_name.lower():
                results.append(("season", series_name, season_name))

            # ÿ®ÿ≠ÿ´ ÿØÿßÿÆŸÑ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ÿØÿßÿÆŸÑ ŸÉŸÑ ŸÖŸàÿ≥ŸÖ
            for ep_num, ep_info in episodes.items():
                if query in ep_num or query in f"{series_name.lower()} {season_name.lower()}":
                    results.append(("episode", series_name, ep_num, season_name))

    if not results:
        await update.message.reply_text("‚ùå ŸÖŸÅŸäÿ¥ ŸÜÿ™ÿßÿ¶ÿ¨.")
        return

    keyboard = []
    for item in results:
        if item[0] == "series":
            _, name = item
            keyboard.append([InlineKeyboardButton(f"üì∫ {name}", callback_data=f"series|{name}")])
        elif item[0] == "season":
            _, series_name, season_name = item
            keyboard.append([InlineKeyboardButton(f"üìÇ {series_name} - {season_name}", callback_data=f"season|{series_name}|{season_name}")])
        elif item[0] == "episode":
            _, series_name, ep_num, season_name = item
            keyboard.append([InlineKeyboardButton(f"üéû {series_name} - {season_name} - ÿ≠ŸÑŸÇÿ© {ep_num}", callback_data=f"episode|{series_name}|{ep_num}")])

    keyboard.append([InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data="back")])

    await update.message.reply_text("üîé ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ®ÿ≠ÿ´:", reply_markup=InlineKeyboardMarkup(keyboard))


# ========== /start ==========
# ÿØÿßŸÑÿ© ŸÑÿ≠ŸÅÿ∏ user_id ŸÅŸä ŸÖŸÑŸÅ users.json
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user

    # ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ
    if not await is_user_subscribed(user.id, context):
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üì¢ ÿ•ÿ¥ÿ™ÿ±ŸÉ ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ© ŸÖŸÜ ŸáŸÜÿß", url="https://t.me/+TjSNl-DGAYgyYjc0")],
            [InlineKeyboardButton("üì¢ ÿ•ÿ¥ÿ™ÿ±ŸÉ ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©  ÿßŸÑÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ© ŸÖŸÜ ŸáŸÜÿß", url="https://t.me/+kmoZ3ILV8O9hM2Zk")],
            [InlineKeyboardButton("üë• ÿ•ÿ¥ÿ™ÿ±ŸÉ ŸÅŸä ÿßŸÑÿ¨ÿ±Ÿàÿ®", url="https://t.me/+Dv65alI3QCgzMzM0")]
        ])
        await update.message.reply_text("‚ö†Ô∏è ŸÑÿßÿ≤ŸÖ ÿ™ÿ¥ÿ™ÿ±ŸÉ ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ© ÿπÿ¥ÿßŸÜ ÿ™ŸÇÿØÿ± ÿ™ÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ®Ÿàÿ™.", reply_markup=keyboard)
        return

    # ÿ™ÿ≥ÿ¨ŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ¨ÿØŸäÿØ
    add_user(user)

    # ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ
    log_usage(user, "start")

    # ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    series_data = load_series_data()
    if not series_data:
        await update.message.reply_text("üìÇ ŸÖŸÅŸäÿ¥ ŸÖÿ≥ŸÑÿ≥ŸÑÿßÿ™ ŸÖÿ∂ÿßŸÅÿ© ÿ≠ÿ™Ÿâ ÿßŸÑÿ¢ŸÜ.")
        return

    # ÿ™ŸàŸÑŸäÿØ ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑÿßÿ™
    buttons = [[InlineKeyboardButton(series_name, callback_data=f"series|{sanitize_callback(series_name)}")]
               for series_name in series_data]

# ‚úÖ ŸÜÿ∂ŸäŸÅ ÿ≤ÿ± ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑÿ¢ÿÆÿ±
    buttons.append([InlineKeyboardButton("üîç ÿ®ÿ≠ÿ´ ÿπŸÜ ŸÖÿ≥ŸÑÿ≥ŸÑ", callback_data="search_series")])


    await update.message.reply_text("üì∫ ÿßÿÆÿ™ÿßÿ± ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑ ÿßŸÑŸÑŸä ÿπÿßŸäÿ≤ ÿ™ÿ¥ŸàŸÅŸá:", reply_markup=InlineKeyboardMarkup(buttons))

# ========== ÿßŸÑÿ∂ÿ∫ÿ∑ÿßÿ™ ==========
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    user = query.from_user
    series_data = load_series_data()

    if data == "admin_list":
        await list_series(update, context)
        return

    if data == "admin_logs":
        await show_logs(update, context)
        return

    if data == "admin_stats":
        stats = get_usage_stats()
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üîô ÿßŸÑÿ±ÿ¨Ÿàÿπ", callback_data="admin")]
        ])
        await query.edit_message_text(stats, parse_mode="HTML", reply_markup=keyboard)
        return

    if data == "admin_broadcast":
        await query.message.reply_text("‚úèÔ∏è ÿßŸÉÿ™ÿ® ÿßŸÑÿ¢ŸÜ ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ•ÿπŸÑÿßŸÜ ÿßŸÑŸÑŸä ÿπÿßŸäÿ≤ ÿ™ÿ®ÿπÿ™Ÿá ŸÑŸÉŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ:")
        context.user_data["awaiting_broadcast"] = True
        return

    if data == "confirm_broadcast":
        message = context.user_data.get("pending_broadcast_message")
        if message:
            success, failed = await broadcast_message(context, message)
            await query.message.reply_text(f"‚úÖ ÿ™ŸÖ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ ŸÑŸÄ {success} ŸÖÿ≥ÿ™ÿÆÿØŸÖÿå ŸàŸÅÿ¥ŸÑ ŸÖÿπ {failed}.")
        else:
            await query.message.reply_text("‚ùó ŸÑÿß ŸäŸàÿ¨ÿØ ÿ±ÿ≥ÿßŸÑÿ© ŸÖÿπŸÑŸÇÿ©.")
        return

    if data == "search_series":
        await query.message.reply_text("üîç ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑ ÿßŸÑŸÑŸä ÿπÿßŸäÿ≤ ÿ™ÿØŸàÿ± ÿπŸÑŸäŸá:")
        context.user_data["awaiting_series_search"] = True
        return

    if data == "back":
        await start(update, context)
        return

    if data.startswith("series|"):
        _, series_name = data.split("|", 1)
        seasons = series_data.get(series_name, {}).get("seasons", {})

        if not seasons:
            await query.message.reply_text("‚ùå ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖŸàÿßÿ≥ŸÖ ŸÑŸáÿ∞ÿß ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑ.")
            return

        log_usage(user, "open_series", series_name)

        keyboard = [
            [InlineKeyboardButton(season, callback_data=f"season|{series_name}|{season}")]
            for season in seasons
        ]
        keyboard.append([InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data="back")])
        await query.message.reply_text(f"üìÇ ŸÖŸàÿßÿ≥ŸÖ ŸÖÿ≥ŸÑÿ≥ŸÑ: {series_name}", reply_markup=InlineKeyboardMarkup(keyboard))

    elif data.startswith("season|"):
        parts = data.split("|")
        if len(parts) >= 3:
            _, series_name, season_name = parts[:3]
        else:
            await query.message.reply_text("‚ùå ÿ®ŸäÿßŸÜÿßÿ™ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©.")
            return

        episodes = series_data.get(series_name, {}).get("seasons", {}).get(season_name, [])

        if not episodes:
            await query.message.reply_text("‚ùå ŸÑÿß ŸäŸàÿ¨ÿØ ÿ≠ŸÑŸÇÿßÿ™ ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑŸÖŸàÿ≥ŸÖ.")
            return

        log_usage(user, "open_season", f"{series_name} - {season_name}")

        keyboard = generate_episode_buttons(series_name, season_name, episodes)
        await query.message.reply_text(f"üé¨ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ({season_name}):", reply_markup=InlineKeyboardMarkup(keyboard))

    elif data.startswith("episode|"):
        parts = data.split("|")
        if len(parts) >= 3:
            _, series_name, episode_num = parts[:3]
        else:
            await query.message.reply_text("‚ùå ÿ®ŸäÿßŸÜÿßÿ™ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©.")
            return

        episodes = series_data.get(series_name, {}).get("episodes", {})
        episode_info = episodes.get(episode_num)

        if episode_info:
            video_id = episode_info["file_id"]
            caption = f"{series_name} - ÿ≠ŸÑŸÇÿ© {episode_num}"
            await query.message.reply_video(video_id, caption=caption)

            log_usage(user, "view", f"{series_name} - ÿ≠ŸÑŸÇÿ© {episode_num}")

# ========== /add ==========
async def add(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not await is_user_subscribed(user.id, context):
        await update.message.reply_text("‚ö†Ô∏è ŸÑÿßÿ≤ŸÖ ÿ™ÿ¥ÿ™ÿ±ŸÉ ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ© ÿπÿ¥ÿßŸÜ ÿ™ŸÇÿØÿ± ÿ™ÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ®Ÿàÿ™ÿå Ÿàÿ®ÿπÿØŸáÿß ÿßÿ±ÿ¨ÿπ ŸáŸÜÿß Ÿàÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ‚¨ÖÔ∏è /start.")
        return
    if not is_admin(user.id):
        await update.message.reply_text("‚ùå ŸÖÿ¥ ŸÖÿ≥ŸÖŸàÿ≠ŸÑŸÉ ÿ™ÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ŸÖÿ± ÿØŸá.")
        return
    if len(context.args) < 2:
        await update.message.reply_text("‚ùó ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ŸÖÿ± ŸÉÿØŸá:\n`/add ÿßÿ≥ŸÖ_ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑ ÿ±ŸÇŸÖ_ÿßŸÑÿ≠ŸÑŸÇÿ©`", parse_mode="Markdown")
        return

    series_name = context.args[0]
    episode_number = context.args[1]
    PENDING_ADDS[user.id] = (series_name, episode_number)
    log_usage(user, "add_episode", f"{series_name} - {episode_number}")
    await update.message.reply_text(f"‚úÖ ÿ™ŸÖÿßŸÖÿå ÿßÿ®ÿπÿ™ŸÑŸä ÿßŸÑÿ≠ŸÑŸÇÿ© (ŸÅŸàÿ±Ÿàÿ±ÿØ ŸÖŸÜ ÿßŸÑÿ¨ÿ±Ÿàÿ®) ŸÉÿ≠ŸÑŸÇÿ© {episode_number} ŸÑŸÖÿ≥ŸÑÿ≥ŸÑ {series_name}")

# ========== ÿßŸÑÿ™ŸÇÿßÿ∑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖŸàÿ¨Ÿáÿ© ==========
async def handle_forward(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in PENDING_ADDS:
        return

    if not update.message.forward_from_chat:
        await update.message.reply_text("‚ö†Ô∏è ŸÑÿßÿ≤ŸÖ ÿ™ÿ®ÿπÿ™ŸÑŸä ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÉŸÄ *Forward* ŸÖŸÜ ÿßŸÑÿ¨ÿ±Ÿàÿ®.", parse_mode="Markdown")
        return

    series_name, episode_number = PENDING_ADDS.pop(user.id)
    series_data = load_series_data()

    if series_name not in series_data:
        series_data[series_name] = {}

    series_data[series_name][episode_number.strip()] = {
    "chat_id": update.message.forward_from_chat.id,
    "message_id": update.message.forward_from_message_id
    }

    save_series_data(series_data)
    log_usage(user, "saved_episode", f"{series_name} - {episode_number}")
    await update.message.reply_text(f"‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ≠ŸÑŸÇÿ© {episode_number} ŸÑŸÖÿ≥ŸÑÿ≥ŸÑ {series_name}")

# ========== /list ==========
async def list_series(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not await is_user_subscribed(user.id, context):
        await (update.message or update.callback_query.message).reply_text("‚ö†Ô∏è ŸÑÿßÿ≤ŸÖ ÿ™ÿ¥ÿ™ÿ±ŸÉ ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©.")
        return

    series_data = load_series_data()
    if not series_data:
        await (update.message or update.callback_query.message).reply_text("‚ùå ŸÖŸÅŸäÿ¥ ÿ®ŸäÿßŸÜÿßÿ™ ÿ≠ÿßŸÑŸäÿßŸã.")
        return

    log_usage(user, "list_series")

    series_names = list(series_data.keys())
    buttons = []

    for i in range(0, len(series_names), SERIES_PER_ROW):
        row = [
            InlineKeyboardButton(series_name, callback_data=f"series|{sanitize_callback(series_name)}")
            for series_name in series_names[i:i + SERIES_PER_ROW]
        ]
        buttons.append(row)

    await (update.message or update.callback_query.message).reply_text(
        "üìö ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑÿßÿ™:",
        reply_markup=InlineKeyboardMarkup(buttons)
    )

# ========== /delete ==========
async def delete_episode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_admin(user.id):
        await update.message.reply_text("‚ùå ŸÖÿ¥ ŸÖÿ≥ŸÖŸàÿ≠ŸÑŸÉ ÿ®ÿßŸÑÿ£ŸÖÿ± ÿØŸá.")
        return
    if len(context.args) < 2:
        await update.message.reply_text("‚ùó ÿßÿ≥ÿ™ÿÆÿØŸÖ ŸÉÿØŸá:\n`/delete ÿßÿ≥ŸÖ_ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑ ÿ±ŸÇŸÖ_ÿßŸÑÿ≠ŸÑŸÇÿ©`", parse_mode="Markdown")
        return

    series_name = context.args[0]
    episode_number = context.args[1]
    series_data = load_series_data()

    if series_name in series_data and episode_number in series_data[series_name]:
        del series_data[series_name][episode_number]
        if not series_data[series_name]:
            del series_data[series_name]
        save_series_data(series_data)
        log_usage(user, "delete_episode", f"{series_name} - {episode_number}")
        await update.message.reply_text(f"üóëÔ∏è ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ≠ŸÑŸÇÿ© {episode_number} ŸÖŸÜ {series_name}.")
    else:
        await update.message.reply_text("‚ùå ÿßŸÑÿ≠ŸÑŸÇÿ© ÿ£Ÿà ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ.")

# ========== /admin ==========
from telegram import InlineKeyboardMarkup, InlineKeyboardButton

async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_admin(user.id):
        await update.message.reply_text("‚ùå ŸÖÿ¥ ŸÖÿ≥ŸÖŸàÿ≠ŸÑŸÉ.")
        return

    data = load_series_data()
    total_series = len(data)
    total_seasons = sum(len(series) for series in data.values())
    total_episodes = sum(len(season) for series in data.values() for season in series.values())

    user_ids = set()
    logs = []
    if os.path.exists(USAGE_LOG_FILE):
        with open(USAGE_LOG_FILE, "r", encoding="utf-8") as f:
            try:
                logs = json.load(f)
                for entry in logs:
                    user_ids.add(entry.get("user_id"))
            except:
                logs = []

    text = f"""üìä ŸÑŸàÿ≠ÿ© ÿ™ÿ≠ŸÉŸÖ ÿßŸÑÿ®Ÿàÿ™:

‚Ä¢ ÿπÿØÿØ ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑÿßÿ™: {total_series}
‚Ä¢ ÿπÿØÿØ ÿßŸÑŸÖŸàÿßÿ≥ŸÖ: {total_seasons}
‚Ä¢ ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™: {total_episodes}
‚Ä¢ ÿπÿØÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ: {len(user_ids)}
‚Ä¢ ÿπÿØÿØ ÿßŸÑÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖÿ≥ÿ¨ŸÑÿ©: {len(logs)}

ÿßÿÆÿ™ÿ± ÿ•ÿ¨ÿ±ÿßÿ°:
"""

    buttons = [
        [
            InlineKeyboardButton("üìÉ ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑÿßÿ™", callback_data="admin_list"),
            InlineKeyboardButton("üìã ÿ≥ÿ¨ŸÑ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ", callback_data="admin_logs")
        ],
        [
            InlineKeyboardButton("üìä ÿπÿ±ÿ∂ ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™", callback_data="admin_stats")
        ],
        [
            InlineKeyboardButton("üì¢ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿπŸÑÿßŸÜ", callback_data="admin_broadcast")
        ],
        [
            InlineKeyboardButton("‚ûï ÿ•ÿ∂ÿßŸÅÿ© ÿ≠ŸÑŸÇÿ©", callback_data="admin_add"),
            InlineKeyboardButton("üóë ÿ≠ÿ∞ŸÅ ÿ≠ŸÑŸÇÿ©", callback_data="admin_delete")
        ],
        [
            InlineKeyboardButton("üè† ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ®ÿØÿßŸäÿ©", callback_data="back_to_series")
        ]
    ]

    await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(buttons))

# ========== /logs ==========
async def show_logs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_admin(user.id):
        await (update.message or update.callback_query.message).reply_text("‚ùå ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ŸÑŸÉ.")
        return

    if not os.path.exists(USAGE_LOG_FILE):
        await (update.message or update.callback_query.message).reply_text("‚ö†Ô∏è ŸÑÿß ŸäŸàÿ¨ÿØ ÿ≥ÿ¨ŸÑ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ.")
        return

    with open(USAGE_LOG_FILE, "r", encoding="utf-8") as f:
        logs = json.load(f)

    text = "üìù ÿ≥ÿ¨ŸÑ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ:\n\n"
    for entry in logs[-50:]:  # ÿ¢ÿÆÿ± 50 ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÅŸÇÿ∑
        line = f"{entry['timestamp']} - {entry['name']} (@{entry['username']}): {entry['action']} {entry['extra']}\n"
        text += line

    if len(text) > 4000:
        text = text[-4000:]

    await (update.message or update.callback_query.message).reply_text(text)

# ========== /broadcast ==========
async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user

    if not is_admin(user.id):
        await update.message.reply_text("‚ùå ŸÖÿ¥ ŸÖÿ≥ŸÖŸàÿ≠ŸÑŸÉ ÿ™ÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ŸÖÿ± ÿØŸá.")
        return

    if not context.args:
        await update.message.reply_text("‚ùó ÿßŸÉÿ™ÿ® ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ®ÿπÿØ ÿßŸÑÿ£ŸÖÿ±ÿå ŸÖÿ´ÿßŸÑ:\n`/broadcast ŸÅŸäŸá ŸÖÿ≥ŸÑÿ≥ŸÑ ÿ¨ÿØŸäÿØ üî•`", parse_mode="Markdown")
        return

    message = " ".join(context.args)
    await update.message.reply_text("‚è≥ ÿ¨ÿßÿ±Ÿä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑŸÉŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ...")
    success, failed = await broadcast_message(context, message)
    await update.message.reply_text(f"üì§ ÿ™ŸÖ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ ŸÑŸÄ {success} ŸÖÿ≥ÿ™ÿÆÿØŸÖÿå ŸàŸÅÿ¥ŸÑ ŸÖÿπ {failed}.")

# ========== ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™ ==========

async def set_commands(app):
    await app.bot.set_my_commands([
        BotCommand("start", "ÿ®ÿØÿ° ÿßŸÑÿ®Ÿàÿ™"),
        BotCommand("admin", "ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ"),
        BotCommand("broadcast", "ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÑŸÉŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ"),
        BotCommand("logs", "ÿ≥ÿ¨ŸÑ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ"),
        BotCommand("list", "ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≥ŸÑÿ≥ŸÑÿßÿ™"),
        BotCommand("add", "ÿ•ÿ∂ÿßŸÅÿ© ÿ≠ŸÑŸÇÿ©"),
        BotCommand("delete", "ÿ≠ÿ∞ŸÅ ÿ≠ŸÑŸÇÿ©"),
    ])

app = ApplicationBuilder().token(TOKEN).post_init(set_commands).build()

app.add_handler(CommandHandler("start", start))
app.add_handler(CommandHandler("admin", admin_panel))
app.add_handler(CommandHandler("broadcast", broadcast_command))
app.add_handler(CommandHandler("list", list_series))
app.add_handler(CommandHandler("add", add))
app.add_handler(CommandHandler("delete", delete_episode))
app.add_handler(CommandHandler("logs", show_logs))
app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), handle_broadcast_input))
app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), handle_series_search))

app.add_handler(CallbackQueryHandler(button_handler))

app.add_handler(MessageHandler(filters.FORWARDED & filters.TEXT, handle_forward))
app.add_handler(MessageHandler(filters.FORWARDED & filters.VIDEO, handle_forward))
app.add_handler(MessageHandler(filters.FORWARDED & filters.PHOTO, handle_forward))

print("‚úÖ ÿßŸÑÿ®Ÿàÿ™ ÿ¥ÿ∫ŸëÿßŸÑ...")
init_db()
app.run_polling()